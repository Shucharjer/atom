## Overview

  This is a modern Entity-Component-System (ECS) framework built with C++20 and
later, designed to deliver zero-cost abstractions while offering a simple,
expressive, and efficient programming model.  

  Inspired by the ergonomics of Bevy, this library leverages compile-time
metaprogramming, domain-specific language (DSL), and concepts to provide rich
type-level information without runtime overhead.  

  The core philosophy is: "What you write is what you get." Systems are plain
functions, components are ordinary types, and scheduling is declarativeâ€”all
resolved at compile time.

## Key Features

-   Zero-runtime-overhead. No virtual dispatch, no heap allocations for system
dispatch.  
-   Compile-time world & schedule construction. Entire execution list is 
generated at compile time.
-   Declarative scheduling. Express dependencies (`before`, `after`) directly
in system registration.
-   Support for async worlds. Run multiple worlds concurrently with shared or 
independent state.
-   DSL-based ergonomic API. Write systems as natural C++ functions, which
means no boierplate.  

## Core Concepts

### 1. Components, Resources

  A type with `component_concept` derived from `component_t` or specified
`as_component` as true is a component. So do the resource. Inspired by bevy,
resouce are global data accessible by each system.

```c++
struct position {
    using component_concept = component_t;
    float x;
    float y;
    float z;
};

// another way to declare a type as a component
struct direction {
    float x;
    float y;
    float z;
};
template <>
constexpr bool as_component<direction> = true;

struct keyboard {
    using resouce_concept = resource_t;
    // ...
};
template <typename O>
struct input : O {
    using resource_concept = typename O::resouce_concept;
};
```

### 2. Get

  We uses class template `query` or `res` to get component or resource data.
Each type parameter in `query` should be a `query_filter` like `with`. This
requested data could be value, cref or ref.

```c++
void update_time(res<timer&> res) {
    auto [timer] = res;
    timer.update();
}
void movement(query<with<position&, const velocity&>> query,
    res<const timer&> res) {
    auto [timer] = res;
    auto delta = timer.delta();
    for (auto [pos, vel] : query.get()) {
        pos += vel * delta;
    }
}
void echo(query<const name&> query) {
    for (auto [entity, name] : query.get_with_entity()) {
        println("entity {} has name: {}", entity, name);
    }
}
```

### 3. Local

  We call variables could not share between systems as `local`.

```c++
void render_system(
    query<with<const position&, const rotation&, scale, visible>> query,
    local<framebuffer_manager> local) {
    ...
}
```

### 4. Commands

  We have already provided command buffer support, which may make this 
framework perform better in multi-thread environment. And the usage is mankind:
users could create entities, add/remove components or kill entities by
`commands`.

```c++
using commands = basic_commands<>;
void example_system(commands cmds) {
    auto entity = cmds.spawn<position>();
}
```

  The entity generated by spawn has type `future_entity_t`, but do not warry,
it could be used as a normal entity.

  **Take care when using multi-thread!** The commands of a system would be
applied when finishing a system list, which means the execution sequence like
the following it not specified.

```c++
void sys1(commands cmds) {
    cmds.spawn<std::string>();
}
void sys2(query<std::string&> qry) {
    for (auto [string] : qry.get()) {
        string = ""; // some value
    }
}
constexpr auto world = world_desc
    | add_system<update, sys1>
    | add_system<update, sys2>;
```

  The solution is easy: specify the execution sequence.

```c++
constexpr auto world = world_desc
    | add_system<update, sys1, before<sys2>>
    | add_system<update, sys2>;
```

## World & Schedule Declaration

  The entire application structure is defined declaratively at compile time
using `constexpr` pipelines.

```c++
constexpr auto world = world_desc
    | add_system<pre_update, update_keyboard_input>
    | add_system<update, movement>
    | add_system<update, physics_system, before<movement>>
    | add_system<post_update, render_system>
    | ...;
```

  When making a "world", it will generate metainfo by parsing the given world
descriptor. Then, when you call a stage, it will execute a run list contains
multi system list, which involves parallelizable systems with internal
execution support.

```c++
auto thread_pool = exec::static_thread_pool{};
auto sch         = thread_pool.get_scheduler();
auto concurrency = thread_pool.avaliable_parallelism();
auto cmdbufs     = std::vector<command_buffer<>>(concurrency);
auto worlds      = make_worlds<::world>();

using enum stage;
call<startup>(sch, cmdbufs, worlds);
```

## Design Principles

### Compile-Time Reflection & Metaprogramming

  The framework inspects system signatures at compile time using tempalte
metaprogramming and DSL to:

-   Infer required components and resouces.
-   Process dependency.
-   Generate optimal iteration code (e.g., SoA layout, cache-friendly access).

### Zero-Cost Abstraction

  All abstractions (queries, resouces, stages) compile down to direct memory
access and function calls--no runtime ECS "engine" overhead.

### Ergonomic Syntax via DSL

  The framework enables intuitivej parameter  declarations that look like
standard C++ but carry semantic meaning.

## Conclusion

  This ECS framework brings the productivity of high-level game engines to C++,
without sacrificing performance. By pushing logic to compile time and embracing
modern C++ idioms, it enables developers to write clear, safe, and blazingly
fast data-oriented code.