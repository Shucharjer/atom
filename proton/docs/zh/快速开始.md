## 概述

这是一个基于C++20以及更高标准构建的现代 **实体-组件-系统** (Entity-Component-System,
ECS) 框架, 旨在提供零运行时开销的抽象, 同时保持简洁, 表达力强且高效的编程模型.

本框架受Bevy引擎的易用性启发, 充分利用编译期元编程, 领域特定语言 (DSL) 以及C++20概念, 在
不引入任何运行时开销的前提下, 提供丰富的类型级信息.

其核心理念是: "所写即所得". 系统就是普通函数, 组件就是普通类型, 调度逻辑完全显式声明--所有
内容均在编译期完成解析.

## 核心特性

-   零运行时开销: 
-   编译期世界与调度构建: 完整的执行序列在编译期生成
-   声明式调度:
-   支持并行
-   DSL风格的简洁API: 系统可直接以自然的C++函数形式编写

## 核心概念

### 1. 组件 (Component) 与资源 (Resource)

任何满足`component_concept`的类型 (可通过继承`component_t`) 或特化`as_component`为
`true`即被视为组件. 资源 (Resource) 类似, 但作用于全局, 所有系统均可访问.

```c++
struct position {
    using component_concept = component_t;
    float x, y, z;
};

// 另一种声明组件的方式
struct direction {
    float x, y, z;
};
template <>
constexpr bool as_component<direction> = true;

// 资源示例
struct keyboard {
    using resource_concept = resource_t;
    // ...
};

// 支持资源的模板继承
template <typename O>
struct input : O {
    using resource_concept = typename O::resource_concept;
};
```

### 2. 数据访问: `query`与`res`

通过`query`和`res`类模板访问组件或资源. `query`的类型参数应为查询过滤器 (如`with`) , 
支持以值, 常量引用或非常量引用的形式请求数据.

```c++
oid update_time(res<timer&> r) {
    auto [timer] = r;
    timer.update();
}

void movement(query<with<position&, const velocity&>> q,
              res<const timer&> r) {
    auto [timer] = r;
    auto delta = timer.delta();
    for (auto [pos, vel] : q.get()) {
        pos.x += vel.x * delta;
        pos.y += vel.y * delta;
        pos.z += vel.z * delta;
    }
}

void echo(query<const name&> q) {
    for (auto [entity, name] : q.get_with_entity()) {
        println("实体 {} 的名称为：{}", entity, name);
    }
}
```

### 3. 本地状态 (Local)

无法在系统间共享的变量称为本地状态 (Local), 每个系统实例拥有其独立副本.

```c++
void render_system(
    query<with<const position&, const rotation&, scale, visible>> qry,
    local<framebuffer_manager> local) {
    // 使用 local 中的本地状态进行渲染
}
```

### 4. 命令 (Commands)

框架内置命令缓冲区 (Command Buffer) 支持, 便于在多线程环境中高效操作世界状态. 用户可通过
`commands`创建/销毁实体、添加/移除组件等.

```c++
using commands = basic_commands<>;
void example_system(commands cmds) {
    auto entity = cmds.spawn<position>(); // 返回 future_entity_t
}
```

**多线程注意事项**: 命令缓冲区的内容仅在当前系列列表的所有系统执行完毕后才被应用. 因此, 
以下代码的执行顺序**未定义**：

```c++
void sys1(commands cmds) {
    cmds.spawn<std::string>();
}
void sys2(query<std::string&> q) {
    for (auto [str] : q.get()) {
        str = "initialized";
    }
}

constexpr auto world = world_desc
    | add_system<update, sys1>
    | add_system<update, sys2>;
```

解决方案很简单, 显式声明依赖关系:

```c++
constexpr auto world = world_desc
    | add_system<update, sys1, before<sys2>>
    | add_system<update, sys2>; // sys1 一定在 sys2 之前执行
```

## 世界与调度的声明

整个应用结构通过`constexpr`管道在编译期声明式定义:

```c++
constexpr auto world = world_desc
    | add_system<pre_update, update_keyboard_input>
    | add_system<update, movement>
    | add_system<update, physics_system, before<movement>>
    | add_system<post_update, render_system>
    | ...;
```

构建“世界”时，框架会解析该描述符，生成元信息。运行时调用某个阶段（stage），将执行一个由多个
系统列表组成的运行序列——其中可并行的系统会自动利用内部并发支持.

```c++
auto thread_pool = exec::static_thread_pool{};
auto sch         = thread_pool.get_scheduler();
auto concurrency = thread_pool.available_parallelism();
auto cmdbufs     = std::vector<command_buffer<>>(concurrency);
auto worlds      = make_worlds<::world>();

using enum stage;
call<startup>(sch, cmdbufs, worlds);
```

## 设计原则

### 编译期反射与元编程

框架在编译期通过模板元编程和 DSL 分析系统签名，从而：

-   自动推导所需组件与资源；
-   解析系统间的依赖关系；
-   生成高度优化的迭代代码（如 SoA 布局、缓存友好的内存访问）。

### 零成本抽象

所有抽象（查询、资源、阶段等）最终都会被编译器优化为直接的内存访问和函数调用，无任何运行时
ECS 引擎开销。

### 基于 DSL 的直观语法

通过精心设计的参数声明语法，让用户以看似普通 C++ 函数的方式编写系统，同时赋予其明确的语义
含义，兼顾表达力与性能。

### 结语

本 ECS 框架将高级游戏引擎的开发效率带入 C++ 领域, 同时不牺牲一丝性能. 通过将逻辑尽可能推
向编译期, 并拥抱现代 C++ 的强大特性, 它使开发者能够编写清晰, 安全且极速的数据导向型代码.